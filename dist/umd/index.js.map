{"version":3,"sources":["webpack://form-linker/webpack/universalModuleDefinition","webpack://form-linker/webpack/bootstrap","webpack://form-linker/./src/index.js","webpack://form-linker/external {\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"root\":\"_\"}"],"names":["options","schema","fields","calcFields","converters","formatters","masks","data","parsedData","setValuesFromParsed","originalData","Object","assign","errors","refs","changeCallback","onChange","prefix","keys","forEach","key","push","fieldName","value","get","isNil","split","converter","triggerCallback","rerender","isEmpty","unset","nested","indexOf","currentPath","slice","lastIndexOf","set","fieldRef","forceUpdate","updateActionFlag","mask","format","parsed","values","setValue","convert","response","formatted","valid","formatter","flag","i","length","getValue","setError","field","validate","original","differences","isEqual","ref","focus","validateAll","error","getError","blur","setTimeout"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"form-linker\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"form-linker\"] = factory(root[\"_\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE_lodash__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","import { get, isEqual, isEmpty, isNil, set, unset } from \"lodash\";\n\nexport default class{\n  constructor(options = {}) {\n    this.schema = options.schema || {};\n    this.fields = this.calcFields();\n    this.converters = options.converters || {};\n    this.formatters = options.formatters || {};\n    this.masks = options.masks || {};\n    this.data = {};\n    this.parsedData = options.data || {};\n    this.setValuesFromParsed(options.data || {});\n    this.originalData = Object.assign({}, this.parsedData);\n    this.errors = {};\n    this.refs = {};\n    this.changeCallback = options.onChange || function() {};\n  }\n\n  // calcFields should be used only to instantiate the fields instance variable\n  calcFields(schema = this.schema, prefix = \"\", fields = []) {\n    Object.keys(schema).forEach((key) => {\n      if(typeof schema[key] === \"object\") {\n        this.calcFields(schema[key], prefix + key + \".\", fields);\n      } else {\n        fields.push(prefix + key);\n      }\n    });\n    return(fields);\n  }\n\n  convert(fieldName, value) {\n    const key = get(this.schema, fieldName);\n\n    if(!isNil(key)) {\n      key.split(\".\").forEach((converter) => {\n        if(!isNil(this.converters[converter])) {\n          value = this.converters[converter](value);\n        }\n      });\n    }\n\n    return(value);\n  }\n\n  /*\n  // ERRORS\n  */\n\n  // getError gets the errors for a specific field\n  getError(fieldName) {\n    return(get(this.errors, fieldName) || []);\n  }\n\n  // getErrors returns the entire error object\n  getErrors() {\n    return(this.errors);\n  }\n\n  // setError removes errors data if an empty array or sets the errors. It also calls the changeCallback,\n  // and rerenders the component if it has registered an update function with the refs.\n  setError(fieldName, errors, triggerCallback = true, rerender = true) {\n    if(isEmpty(errors)) {\n      unset(this.errors, fieldName);\n      const nested = fieldName.indexOf(\".\") > -1;\n      if(nested) {\n        let currentPath = fieldName.slice(0, fieldName.lastIndexOf(\".\"));\n        while(currentPath) {\n          if(isEmpty(get(this.errors, currentPath))) {\n            unset(this.errors, currentPath);\n            currentPath = currentPath.slice(0, currentPath.lastIndexOf(\".\"));\n          } else {\n            break;\n          }\n        }\n      }\n    } else {\n      set(this.errors, fieldName, errors);\n    }\n    if(rerender) {\n      const fieldRef = get(this.refs, fieldName);\n      if(typeof fieldRef?.forceUpdate === \"function\") {\n        fieldRef.forceUpdate();\n      }\n    }\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  // setErrors sets the errors object. It also calls the changeCallback.\n  setErrors(errors, triggerCallback = true) {\n    this.errors = errors;\n    this.fields.forEach(fieldName => {\n      const fieldRef = get(fieldName, errors) && get(fieldName, this.refs);\n      if(typeof fieldRef?.forceUpdate === \"function\") {\n        fieldRef.forceUpdate();\n      }\n    });\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  /*\n  // VALUES\n  */\n\n  // getValue gets the value of the field. Sets the value to an empty string if not an array, not a number, not a boolean, and empty.\n  getValue(fieldName) {\n    return(get(this.data, fieldName));\n  }\n\n  // getValues returns the data object.\n  getValues() {\n    return(this.data);\n  }\n\n  /**\n   * setValue sets the field value to the masked value passed in. It also calls the changeCallback.\n   * The updateActionFlag provides a way to let the associated React component know if this is part of\n   * an event like setValues or validateAll, where some additional action may be taken in the component.\n   * Leave it as false for regular onChange updates.\n   */\n  setValue(fieldName, value, triggerCallback = true, updateActionFlag = false) {\n    set(this.data, fieldName, this.mask(fieldName, value));\n    set(this.parsedData, fieldName, this.format(fieldName, value).parsed);\n    const fieldRef = get(this.refs, fieldName);\n    if(typeof fieldRef?.forceUpdate === \"function\") {\n      fieldRef.forceUpdate(updateActionFlag);\n    }\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  // setValues sets the field value to the masked value for each fieldName path in the values object passed in. It also calls the changeCallback.\n  setValues(values, triggerCallback = true) {\n    this.fields.forEach((fieldName) => {\n      const value = get(values, fieldName);\n      if(typeof value !== \"undefined\") {\n        this.setValue(fieldName, value, false, true);\n      }\n    });\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  setValuesFromParsed(values) {\n    this.fields.forEach((fieldName) => {\n      const value = get(values, fieldName);\n      if(typeof value !== \"undefined\") {\n        this.setValue(fieldName, this.convert(fieldName, value), false, true);\n      }\n    });\n  }\n\n  /*\n   * FORMATTING\n  */\n\n  // format returns formatter results. If no formatter is defined for the schema key, then the formatter structure is returned assuming true.\n  format(fieldName, value) {\n    const key = get(this.schema, fieldName);\n    let response = {\n      errors: [],\n      formatted: value,\n      parsed: value,\n      valid: true\n    };\n\n    if(!isNil(key)) {\n      key.split(\".\").forEach((formatter) => {\n        if(!isNil(this.formatters[formatter])) {\n          response = this.formatters[formatter](response);\n        }\n      });\n    }\n\n    return(response);\n  }\n\n  /*\n   * MASKING\n  */\n\n  // mask masks data based on schema key. If no mask is defined for the schema key, then the original value is returned.\n  mask(fieldName, value) {\n    const key = get(this.schema, fieldName);\n    let response = value;\n\n    if(!isNil(key)) {\n      key.split(\".\").forEach((mask) => {\n        if(!isNil(this.masks[mask])) {\n          response = this.masks[mask].mask(value);\n        }\n      });\n    }\n\n    return(response);\n  }\n\n  /*\n   * VALIDATION\n  */\n\n  isValid() {\n    let flag = true;\n    for(let i = 0; i < this.fields.length; i++) {\n      const{ valid } = this.format(this.fields[i], this.getValue(this.fields[i]));\n      if(valid === false) {\n        flag = false;\n        break;\n      }\n    }\n    return(flag);\n  }\n\n  validate(fieldName, triggerCallback = true) {\n    const{ errors, formatted, parsed } = this.format(fieldName, this.getValue(fieldName));\n    this.setError(fieldName, errors, false, false);\n    this.setValue(fieldName, formatted, false, true);\n    set(this.parsedData, fieldName, parsed);\n\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  validateAll(triggerCallback = true) {\n    this.fields.forEach((field) => {\n      this.validate(field, false);\n    });\n\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  /*\n  // Differences\n  */\n\n  // extractDifferences returns an object of every key that has changed with the value it has changed to. This is great for sending only changes.\n  extractDifferences(original) {\n    const differences = {};\n    const data = this.parsedData;\n\n    this.fields.forEach((field) => {\n      if((isNil(get(original, field)) || get(original, field) === \"\") && (isNil(get(data, field)) || get(data, field) === \"\")) {\n        // do nothing\n      } else if(!isEqual(get(original, field), get(data, field))) {\n        set(differences, field, get(data, field));\n      }\n    });\n    return(differences);\n  }\n\n  /*\n   * REFS\n   */\n\n  /**\n   * ref should be an object with keys \"forceUpdate\" and \"inputRef\".\n   * forceupdate should be a function that causes a rerender of the associated component.\n   * inputRef.current should point to the input element rendered by the component,\n   * or in the case of MultiSelect, RichEditor, & Summernote, the instance of a React Component.\n   */\n  setRef(fieldName, ref) {\n    if(isNil(ref)) {\n      unset(this.refs, fieldName);\n    } else {\n      set(this.refs, fieldName, ref);\n    }\n  }\n\n  // returns the ref to the rendered input element for the fieldName\n  getRef(fieldName) {\n    return(get(this.refs, fieldName + \".inputRef.current\"));\n  }\n\n  // Sets focus on the input associated with fieldName.\n  // Finds the first field in the schema with a ref if no fieldName is given.\n  focusOnField(fieldName) {\n    let ref;\n    if(isNil(fieldName)) {\n      for(const field of this.fields) {\n        ref = get(this.refs, field + \".inputRef.current\");\n        if(!isNil(ref)) {\n          break;\n        }\n      }\n    } else {\n      ref = get(this.refs, fieldName + \".inputRef.current\");\n    }\n    if(typeof ref?.focus === \"function\") {\n      ref.focus();\n    }\n  }\n\n  // Runs validation on the form and scrolls to the first field in the schema/form on the page with an error.\n  scrollToError() {\n    this.validateAll(false);\n    let fieldName, error, ref;\n    for(const field of this.fields) {\n      error = this.getError(field);\n      if(!isEmpty(error)) {\n        ref = get(this.refs, field + \".inputRef.current\");\n        if(!isNil(ref)) {\n          fieldName = field;\n          break;\n        }\n      }\n    }\n    if(isNil(fieldName)) {\n      return;\n    }\n    if(typeof ref.focus === \"function\") {\n      ref.focus();\n      if(typeof ref.blur === \"function\") {\n        setTimeout(() => {\n          ref.blur();\n        });\n      }\n      this.setError(fieldName, error);\n    }\n  }\n\n  /*\n   * SCHEMA\n  */\n\n  updateSchema(schema) {\n    this.schema = schema || {};\n    this.fields = this.calcFields();\n    this.validateAll();\n    this.errors = {};\n  }\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE_lodash__;"],"sourceRoot":""}